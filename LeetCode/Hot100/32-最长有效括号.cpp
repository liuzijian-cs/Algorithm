//
// Created by alpha on 2025/6/25.
//

#include <iostream>
#include <vector>
using namespace std;

// 思路:
// 验证括号的有效的话我觉得整个程序还是要基于栈（至于里面存的东西需要思考一下）
// 然后基于动态规划的思想，分配一个dp数组（大小应该是s.size()+1），初始状态dp[0]肯定是0;
// 然后一个计数器，如果碰到左括号，则将计数器的值入栈

// ( ( )
// 1 2 3 i=0, num=0, dp[0]=0  stack:
// 1 2 3
// i=1, num=1, dp[1]=0, stack:1
// i=2, num=2, dp[2]=0, stack:1,2
// i=3, num=3, dp[3]=2, stack:1


// ) ( ) ( ) )
// 1 2 3 4 5 6
// i=0, num=0, dp[0]=0  stack:
// i=1, num=0*, dp[1]=0, stack:
// i=2, num=1, dp[2]=0, stack:1
// i=3, num=2, dp[3]=2, stack:


// 大致分析一下，dp中保存的应该是最大的有效长度，至于栈有没有用我还在思考


// 分析：
// 这是一个经典的动态规划问题，需要找到最长有效括号子串的长度。关键是要理解"连续"和"有效"的含义。
// 你的思路方向是正确的，提到了栈和动态规划，这确实是解决这个问题的有效方法。不过让我帮你完善一下：

// 你的思路优点：
// 1. 正确识别了需要使用栈来匹配括号
// 2. 考虑了动态规划的思想
// 3. 意识到需要跟踪有效长度

// 需要完善的地方：
// 栈中应该存储索引而不是计数器
// DP数组的含义需要更明确
// 需要考虑更多边界情况

// 我们用 dp[i] 表示以第i个字符结尾的最长有效括号子串的长度。
// 所有 dp[i] 初始化为0。dp[0] 必须为0，因为以第0个字符结尾的子串不可能是有效括号（无匹配）。
// 状态转移方程和逻辑（State Transition and Logic）：
// 我们要从 i = 1 开始遍历字符串，因为要至少两个字符才能配成一对。

// 情况一：s[i] == ')' 且 s[i-1] == '('，即: 出现了 "()" 这样直接配对的结构
// ...()，这种情况下，dp[i] = dp[i-2] + 2。也就是这个子串长度是前面有效区间加上新的一对括号的2。

// 情况二：s[i] == ')' 且 s[i-1] == ')'，即最近两个字符全是右括号，需要回溯查找和其配对的左括号
// 先看前面那个右括号结尾的有效长度 dp[i-1] 有多长。看在它前面一个字符（即 i - dp[i-1] -
// 1）是不是左括号。如果是，则形成新的配对。

// 只有这两种情况会成功匹配，因此在动态规划的版本中，我们并不需要一个栈

// 那么，开始实践吧🫡~

// 100%-31.3% 45min
class Solution {
public:
    int longestValidParentheses(string s) {
        // Boundary：
        if (s.size() < 2) return 0;

        vector<int> dp(s.size(), 0);
        dp[0] = 0;

        int max = 0;

        for (int i = 1; i < s.size(); i++) {
            // condition 1: ( )
            if (s[i] == ')' && s[i - 1] == '(')  dp[i] = (i >= 2 ? dp[i - 2] : 0) + 2;
            // condition 2: ) )
            // ( ( ) )
            // ( ) ( ( ) )
            else if (s[i] == ')' && s[i - 1] == ')') {
                int index = i - dp[i - 1] - 1;
                if (index >= 0 && s[index]=='(')
                    dp[i] = dp[i - 1] + 2 + (index >= 1 ? dp[index - 1] : 0);
            }
            max = max > dp[i] ? max : dp[i];
        }
        return max;
    }
};
